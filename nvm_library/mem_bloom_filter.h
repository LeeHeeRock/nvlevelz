#ifndef MEM_BLOOM_FILTER_H
#define MEM_BLOOM_FILTER_H

#include <string>
#include "leveldb/slice.h"
#include "util/hash.h"
#include "util/random.h"

namespace leveldb {

class MemBloomFilter {
 private:
  size_t bits_per_key_;
  size_t k_;
  size_t key_estimated_;
  std::string filter_;
  size_t filter_size_;
  size_t filter_bits_;

  struct Sleepy {
      enum {WorkBase = 7, SleepingRate = 100, CountLimit = 1000};
      Random rnd_;
      size_t usage_;
      size_t reject_;
      // if reject_ * WorkBase >= usage_, it's helpful.
      bool sleepy_;
      Sleepy() : rnd_(0xdeadbeef), usage_(100), reject_(100), sleepy_(false) {}
      inline void Record(bool accepted) {
          if (!accepted)
              reject_++;
          ++usage_;
          bool awake = reject_ * WorkBase >= usage_;
          if (sleepy_) {
              if (awake)
                  sleepy_ = false;
          } else {
              if (!awake)
                  sleepy_ = true;
          }
          if (usage_ >= CountLimit) {
              usage_ >>= 1;
              reject_ >>= 1;
          }
      }
      bool isSleeping() {
          if (sleepy_) {
              return rnd_.Next() % SleepingRate > 0;
          }
          return false;
      }
  } sheep_;

  inline static uint32_t BloomHash(const Slice& key) {
    return Hash(key.data(), key.size(), 0xbc9f1d34);
  }
 public:
  explicit MemBloomFilter(int64_t memory, int key_estimated)
      : bits_per_key_(memory / key_estimated), key_estimated_(key_estimated) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key_ * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;

    // Compute bloom filter size (in both bits and bytes)
    filter_bits_ = key_estimated_ * bits_per_key_;
    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (filter_bits_ < 64) filter_bits_ = 64;
    filter_size_ = (filter_bits_ + 7) / 8;
    filter_bits_ = filter_size_ * 8;

    filter_ = "";
    filter_.resize(filter_size_, 0);
    filter_.push_back(static_cast<char>(k_));  // Remember # of probes in filter
  }

  const char* Name() const {
    return "leveldb.DynamicBloomFilter";
  }

  void InsertKey(const Slice& key){
    char* array = &filter_[0];
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k_; j++) {
      const uint32_t bitpos = h % filter_bits_;
      array[bitpos/8] |= (1 << (bitpos % 8));
      h += delta;
    }
  }

  bool KeyMayMatch(const Slice& key) {
    assert(filter_size_ > 0);
    if (sheep_.isSleeping()) return true;

    const char* array = filter_.c_str();

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[filter_size_];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      sheep_.Record(true);
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % filter_bits_;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) {
          sheep_.Record(false);
          return false;
      }
      h += delta;
    }
    sheep_.Record(false);
    return true;
  }

  // No copying allowed
  MemBloomFilter(const MemBloomFilter&) = delete;
  void operator=(const MemBloomFilter&) = delete;
};

};
#endif // MEM_BLOOM_FILTER_H
